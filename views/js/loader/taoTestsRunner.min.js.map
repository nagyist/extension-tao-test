{"version":3,"mappings":"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","names":["define","_","areaBroker$1","requireAreas","areaBroker","defaultObjects","map","pluginFactory","hostName","eventNs","probeHandler","now","data","id","type","timestamp","timezone","overseer","probe","collectLatencyEvent","runner","startHandler","marker","stopHandler","last","args","collectEvent","queueStorage","probes","queue","immutableQueue","writing","started","getStorage","Promise","resetStorage","add","name","length","getQueue","getProbes","push","flush","resolve","start","stop","removeHandler","moment","uuid","timeZone","slice","execStack","dataHolder","proxy","probeOverseer","testStore","pluginFactories","config","plugins","states","init","ready","render","finish","destroy","itemStates","provider","providerRun","_this","trigger","catch","reportError","then","_this2","loadItem","_this3","itemRef","itemData","renderItem","_this4","unloadItem","_this5","disableItem","_this6","enableItem","_this7","_this8","_this9","_this10","getConfig","getOptions","getPlugins","getPlugin","getPluginsConfig","getPluginConfig","getAreaBroker","getProxy","getProbeOverseer","getTestStore","getPluginStore","loadedStore","getState","setState","getPersistentState","state","setPersistentState","stored","getItemState","setItemState","loaded","disabled","getTestData","setTestData","getTestContext","setTestContext","getTestMap","setTestMap","getDataHolder","next","previous","jump","skip","exit","pause","resume","timeout","after","eventifier","providerRegistry","dataHolderFactory","extraCallParams","middlewares","list","middleware","async","err","reject","command","params","initialized","delegateProxy","status","communicator","communicatorPromise","testDataHolder","proxyAdapter","initConfig","tokenHandler","onlineStatus","use","install","destroyCommunicator","setOnline","setOffline","isOnline","isOffline","isConnectivityError","getTokenHandler","hasCommunicator","getCommunicator","self","on","channel","communicatorInstance","send","addCallActionParams","sendVariables","callTestAction","getItem","submitItem","callItemAction","telemetry","connectivity","response","msg","wrapper","delegator","tokenHandlerFactory","_defaults","_slice","key","Object","value","enumerable","configurable","writable","obj","providers","loadFromBundle","loadAndRegisterProvider","providersToLoad","target","loadedProviders","registration","itemRunner","logger","loggerFactory","providerLoader","pluginLoader","_communicator","_runner","_proxy","_itemRunner","_typeof","requiredProperties","container","template","validateTestRunnerConfiguration","getOption","getRunner","setTemplate","results","runnerConfig","renderTo","acc","spread","component","runnerFactory","Handlebars","helpers","testMode","storeNames","volatiles","changeTracking","isStoreModeUnified","selectStoreMode","result","modes","getStore","loadStore","isUnified","store","keyPattern","storeKey","getItems","setItem","trackChange","removeItem","clear","setVolatile","clearVolatileIfStoreChange","shouldClear","clearVolatileStores","clearing","startChangeTracking","hasChanges","resetChanges","remove","preselectedBackend","getStorageIdentifier","legacyPrefixes","unified","fragmented"],"sources":["/github/workspace/tao/views/build/config-wrap-start-default.js","../runner/areaBroker.js","../runner/dataHolder.js","../runner/plugin.js","../runner/probeOverseer.js","../runner/runner.js","../runner/proxy.js","../runner/providerLoader.js","../runner/proxy/sample.js","../runner/runnerComponent.js","../runner/testStore.js","module-create.js","/github/workspace/tao/views/build/config-wrap-end-default.js"],"sourcesContent":["\n","define('taoTests/runner/areaBroker',['lodash', 'ui/areaBroker'], function (_, areaBroker$1) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    areaBroker$1 = areaBroker$1 && Object.prototype.hasOwnProperty.call(areaBroker$1, 'default') ? areaBroker$1['default'] : areaBroker$1;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n    var requireAreas = ['content', //where the content is renderer, for example an item\n    'toolbox', //the place to add arbitrary tools, like a zoom, a comment box, etc.\n    'navigation', //the navigation controls like next, previous, skip\n    'control', //the control center of the test, progress, timers, etc.\n    'header', //the area that could contains the test titles\n    'panel' //a panel to add more advanced GUI (item review, navigation pane, etc.)\n    ];\n    /**\n     * Creates an area broker with the required areas for the test runner.\n     *\n     * @see ui/areaBroker\n     *\n     * @param {jQueryElement|HTMLElement|String} $container - the main container\n     * @param {Object} mapping - keys are the area names, values are jQueryElement\n     * @returns {broker} the broker\n     * @throws {TypeError} without a valid container\n     */\n\n    var areaBroker = _.partial(areaBroker$1, requireAreas);\n\n    return areaBroker;\n\n});\n\n","define('taoTests/runner/dataHolder',[],function () { 'use strict';\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n\n    /**\n     * Holds the test runner data.\n     *\n     * @example\n     * var holder = holder();\n     * holder.get('testMap');\n     *\n     * @author Bertrand Chevrier <bertrand@taotesting.com>\n     */\n\n    /**\n     * @type {String[]} the list of default objects to create\n     */\n    var defaultObjects = ['testContext', 'testMap'];\n    /**\n     * Creates a new data holder,\n     * with default entries.\n     *\n     * @returns {Map} the holder\n     */\n\n    function dataHolderFactory() {\n      var map = new Map();\n      defaultObjects.forEach(function (entry) {\n        map.set(entry, {});\n      });\n      return map;\n    }\n\n    return dataHolderFactory;\n\n});\n\n","define('taoTests/runner/plugin',['lodash', 'core/plugin'], function (_, pluginFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    pluginFactory = pluginFactory && Object.prototype.hasOwnProperty.call(pluginFactory, 'default') ? pluginFactory['default'] : pluginFactory;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n    /**\n     * A pluginFactory configured for the test runner\n     * @returns {Function} the preconfigured plugin factory\n     */\n\n    var plugin = _.partialRight(pluginFactory, {\n      //alias getHost to getTestRunner\n      hostName: 'testRunner'\n    });\n\n    return plugin;\n\n});\n\n","define('taoTests/runner/probeOverseer',['lodash', 'moment', 'lib/uuid', 'lib/moment-timezone.min'], function (_, moment, uuid, momentTimezone_min) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    moment = moment && Object.prototype.hasOwnProperty.call(moment, 'default') ? moment['default'] : moment;\n    uuid = uuid && Object.prototype.hasOwnProperty.call(uuid, 'default') ? uuid['default'] : uuid;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n     *\n     */\n    var timeZone = moment.tz.guess();\n    var slice = Array.prototype.slice;\n    /**\n     * Create the overseer intance\n     * @param {runner} runner - a instance of a test runner\n     * @returns {probeOverseer} the new probe overseer\n     * @throws TypeError if something goes wrong\n     */\n\n    function probeOverseerFactory(runner) {\n      // the created instance\n      var overseer; // the list of registered probes\n\n      var probes = []; //temp queue\n\n      var queue = []; //immutable queue which will not be flushed\n\n      var immutableQueue = [];\n      /**\n       * @type {Storage} to store the collected events\n       */\n\n      var queueStorage;\n      /**\n       * @type {Promise} Promises chain to avoid write collisions\n       */\n\n      var writing = Promise.resolve(); //is the overseer started\n\n      var started = false;\n      /**\n       * Get the storage instance\n       * @returns {Promise} that resolves with the storage\n       */\n\n      var getStorage = function getStorage() {\n        if (queueStorage) {\n          return Promise.resolve(queueStorage);\n        }\n\n        return runner.getTestStore().getStore('test-probe').then(function (newStorage) {\n          queueStorage = newStorage;\n          return Promise.resolve(queueStorage);\n        });\n      };\n      /**\n       * Unset the storage instance\n       */\n\n\n      var resetStorage = function resetStorage() {\n        queueStorage = null;\n      };\n      /**\n       * Register the collection event of a probe against a runner\n       * @param {Object} probe - a valid probe\n       */\n\n\n      function collectEvent(probe) {\n        var eventNs = \".probe-\".concat(probe.name); //event handler registered to collect data\n\n        var probeHandler = function probeHandler() {\n          var now = moment();\n          var data = {\n            id: uuid(12, 16),\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n\n          if (typeof probe.capture === 'function') {\n            data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n          }\n\n          overseer.push(data);\n        }; //fallback\n\n\n        if (probe.latency) {\n          return collectLatencyEvent(probe);\n        }\n\n        _.forEach(probe.events, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(probeHandler, eventName));\n        });\n      }\n\n      function collectLatencyEvent(probe) {\n        var eventNs = \".probe-\".concat(probe.name); //start event handler registered to collect data\n\n        var startHandler = function startHandler() {\n          var now = moment();\n          var data = {\n            id: uuid(12, 16),\n            marker: 'start',\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n\n          if (typeof probe.capture === 'function') {\n            data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n          }\n\n          overseer.push(data);\n        }; //stop event handler registered to collect data\n\n\n        var stopHandler = function stopHandler() {\n          var now = moment();\n          var last;\n          var data = {\n            type: probe.name,\n            timestamp: now.format('x') / 1000,\n            timezone: now.tz(timeZone).format('Z')\n          };\n          var args = slice.call(arguments);\n          last = _.findLast(immutableQueue, {\n            type: probe.name,\n            marker: 'start'\n          });\n\n          if (last && !_.findLast(immutableQueue, {\n            type: probe.name,\n            marker: 'end',\n            id: last.id\n          })) {\n            data.id = last.id;\n            data.marker = 'end';\n\n            if (typeof probe.capture === 'function') {\n              data.context = probe.capture.apply(probe, [runner].concat(args));\n            }\n\n            overseer.push(data);\n          }\n        }; //fallback\n\n\n        if (!probe.latency) {\n          return collectEvent(probe);\n        }\n\n        _.forEach(probe.startEvents, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(startHandler, eventName));\n        });\n\n        _.forEach(probe.stopEvents, function (eventName) {\n          var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n          runner.on(listen, _.partial(stopHandler, eventName));\n        });\n      } //argument validation\n\n\n      if (!_.isPlainObject(runner) || !_.isFunction(runner.init) || !_.isFunction(runner.on)) {\n        throw new TypeError('Please set a test runner');\n      }\n      /**\n       * @typedef {probeOverseer}\n       */\n\n\n      overseer = {\n        /**\n         * Add a new probe\n         * @param {Object} probe\n         * @param {String} probe.name - the probe name\n         * @param {Boolean} [probe.latency = false] - simple or latency mode\n         * @param {String[]} [probe.events] - the list of events to listen (simple mode)\n         * @param {String[]} [probe.startEvents] - the list of events to mark the start (lantency mode)\n         * @param {String[]} [probe.stopEvents] - the list of events to mark the end (latency mode)\n         * @param {Function} [probe.capture] - lambda fn to define the data context, it receive the test runner and the event parameters\n         * @returns {probeOverseer} chains\n         * @throws TypeError if the probe is not well formatted\n         */\n        add: function add(probe) {\n          // probe structure strict validation\n          if (!_.isPlainObject(probe)) {\n            throw new TypeError('A probe is a plain object');\n          }\n\n          if (!_.isString(probe.name) || _.isEmpty(probe.name)) {\n            throw new TypeError('A probe must have a name');\n          }\n\n          if (_.where(probes, {\n            name: probe.name\n          }).length > 0) {\n            throw new TypeError('A probe with this name is already regsitered');\n          }\n\n          if (probe.latency) {\n            if (_.isString(probe.startEvents) && !_.isEmpty(probe.startEvents)) {\n              probe.startEvents = [probe.startEvents];\n            }\n\n            if (_.isString(probe.stopEvents) && !_.isEmpty(probe.stopEvents)) {\n              probe.stopEvents = [probe.stopEvents];\n            }\n\n            if (!probe.startEvents.length || !probe.stopEvents.length) {\n              throw new TypeError('Latency based probes must have startEvents and stopEvents defined');\n            } //if already started we register the events on addition\n\n\n            if (started) {\n              collectLatencyEvent(probe);\n            }\n          } else {\n            if (_.isString(probe.events) && !_.isEmpty(probe.events)) {\n              probe.events = [probe.events];\n            }\n\n            if (!_.isArray(probe.events) || probe.events.length === 0) {\n              throw new TypeError('A probe must define events');\n            } //if already started we register the events on addition\n\n\n            if (started) {\n              collectEvent(probe);\n            }\n          }\n\n          probes.push(probe);\n          return this;\n        },\n\n        /**\n         * Get the time entries queue\n         * @returns {Promise} with the data in parameterj\n         */\n        getQueue: function getQueue() {\n          return getStorage().then(function (storage) {\n            return storage.getItem('queue');\n          });\n        },\n\n        /**\n         * Get the list of defined probes\n         * @returns {Object[]} the probes collection\n         */\n        getProbes: function getProbes() {\n          return probes;\n        },\n\n        /**\n         * Push a time entry to the queue\n         * @param {Object} entry - the time entry\n         */\n        push: function push(entry) {\n          getStorage().then(function (storage) {\n            //ensure the queue is pushed to the store consistently and atomically\n            writing = writing.then(function () {\n              queue.push(entry);\n              immutableQueue.push(entry);\n              return storage.setItem('queue', queue);\n            });\n          });\n        },\n\n        /**\n         * Flush the queue and get the entries\n         * @returns {Promise} with the data in parameter\n         */\n        flush: function flush() {\n          return new Promise(function (resolve) {\n            getStorage().then(function (storage) {\n              writing = writing.then(function () {\n                return storage.getItem('queue').then(function (flushed) {\n                  queue = [];\n                  return storage.setItem('queue', queue).then(function () {\n                    resolve(flushed);\n                  });\n                });\n              });\n            });\n          });\n        },\n\n        /**\n         * Start the probes\n         * @returns {Promise} once started\n         */\n        start: function start() {\n          return getStorage().then(function (storage) {\n            return storage.getItem('queue').then(function (savedQueue) {\n              if (_.isArray(savedQueue)) {\n                queue = savedQueue;\n                immutableQueue = savedQueue;\n              }\n\n              _.forEach(probes, collectEvent);\n\n              started = true;\n            });\n          });\n        },\n\n        /**\n         * Stop the probes\n         * Be carefull, stop will also clear the store and the queue\n         * @returns {Promise} once stopped\n         */\n        stop: function stop() {\n          started = false;\n\n          _.forEach(probes, function (probe) {\n            var eventNs = \".probe-\".concat(probe.name);\n\n            var removeHandler = function removeHandler(eventName) {\n              runner.off(eventName + eventNs);\n            };\n\n            _.forEach(probe.startEvents, removeHandler);\n\n            _.forEach(probe.stopEvents, removeHandler);\n\n            _.forEach(probe.events, removeHandler);\n          });\n\n          queue = [];\n          immutableQueue = [];\n          return getStorage().then(function (storage) {\n            return storage.removeItem('queue').then(resetStorage);\n          });\n        }\n      };\n      return overseer;\n    }\n\n    return probeOverseerFactory;\n\n});\n\n","define('taoTests/runner/runner',['lodash', 'core/eventifier', 'core/providerRegistry', 'taoTests/runner/dataHolder'], function (_, eventifier, providerRegistry, dataHolderFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    eventifier = eventifier && Object.prototype.hasOwnProperty.call(eventifier, 'default') ? eventifier['default'] : eventifier;\n    providerRegistry = providerRegistry && Object.prototype.hasOwnProperty.call(providerRegistry, 'default') ? providerRegistry['default'] : providerRegistry;\n    dataHolderFactory = dataHolderFactory && Object.prototype.hasOwnProperty.call(dataHolderFactory, 'default') ? dataHolderFactory['default'] : dataHolderFactory;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2020 (original work) Open Assessment Technologies SA ;\n     */\n    /**\n     * Builds an instance of the QTI test runner\n     *\n     * @param {String} providerName\n     * @param {Function[]} pluginFactories\n     * @param {Object} config\n     * @param {String} config.serviceCallId - the identifier of the test session\n     * @param {String} [config.testDefinition] - the identifier of the test definition\n     * @param {String} [config.testCompilation] - the identifier of the compiled test\n     * @param {Object} config.options - the test runner configuration options\n     * @param {Object} config.options.plugins - the plugins configuration\n     * @param {jQueryElement} [config.renderTo] - the dom element that is going to holds the test content (item, rubick, etc)\n     * @returns {runner}\n     */\n\n    function testRunnerFactory(providerName) {\n      var pluginFactories = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      /**\n       * @type {Object} The test runner instance\n       */\n      var runner;\n      /**\n       * @type {Map} Contains the test runner data\n       */\n\n      var dataHolder;\n      /**\n       * @type {Object} the registered plugins\n       */\n\n      var plugins = {};\n      /**\n       * @type {Object} the test of the runner\n       */\n\n      var states = {\n        init: false,\n        ready: false,\n        render: false,\n        finish: false,\n        destroy: false\n      };\n      /**\n       * @type {Object} keeps the states of the items\n       */\n\n      var itemStates = {};\n      /**\n       * The selected test runner provider\n       */\n\n      var provider = testRunnerFactory.getProvider(providerName);\n      /**\n       * Keep the area broker instance\n       * @see taoTests/runner/areaBroker\n       */\n\n      var areaBroker;\n      /**\n       * Keep the proxy instance\n       * @see taoTests/runner/proxy\n       */\n\n      var proxy;\n      /**\n       * Keep the instance of the probes overseer\n       * @see taoTests/runner/probeOverseer\n       */\n\n      var probeOverseer;\n      /**\n       * Keep the instance of a testStore\n       * @see taoTests/runner/testStore\n       */\n\n      var testStore;\n      /**\n       * Run a method of the provider (by delegation)\n       *\n       * @param {String} method - the method to run\n       * @param {...} args - rest parameters given to the provider method\n       * @returns {Promise} so provider can do async stuffs\n       */\n\n      function providerRun(method) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return new Promise(function (resolve) {\n          if (!_.isFunction(provider[method])) {\n            return resolve();\n          }\n\n          return resolve(provider[method].apply(runner, args));\n        });\n      }\n      /**\n       * Run a method in all plugins\n       *\n       * @param {String} method - the method to run\n       * @returns {Promise} once that resolve when all plugins are done\n       */\n\n\n      function pluginRun(method) {\n        var execStack = [];\n\n        _.forEach(runner.getPlugins(), function (plugin) {\n          if (_.isFunction(plugin[method])) {\n            execStack.push(plugin[method]());\n          }\n        });\n\n        return Promise.all(execStack);\n      }\n      /**\n       * Trigger error event\n       * @param {Error|String} err - the error\n       * @fires runner#error\n       */\n\n\n      function reportError(err) {\n        runner.trigger('error', err);\n      }\n      /**\n       * Defines the test runner\n       *\n       * @type {runner}\n       */\n\n\n      runner = eventifier({\n        /**\n         * Initialize the runner\n         *  - instantiate the plugins\n         *  - provider init\n         *  - plugins init\n         *  - call render\n         * @fires runner#init\n         * @returns {runner} chains\n         */\n        init: function init() {\n          var _this = this;\n\n          if (!dataHolder) {\n            dataHolder = this.getDataHolder();\n          } //instantiate the plugins first\n\n\n          _.forEach(pluginFactories, function (pluginFactory) {\n            var plugin = pluginFactory(runner, _this.getAreaBroker());\n            plugins[plugin.getName()] = plugin;\n          });\n\n          providerRun('install').then(_.partial(providerRun, 'loadPersistentStates')).then(_.partial(pluginRun, 'install')).then(_.partial(providerRun, 'init')).then(_.partial(pluginRun, 'init')).then(function () {\n            _this.setState('init', true).off('init.internal').after('init.internal', function () {\n              return _this.render();\n            }).trigger('init');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Render the runner\n         *  - provider render\n         *  - plugins render\n         * @fires runner#render\n         * @fires runner#ready\n         * @returns {runner} chains\n         */\n        render: function render() {\n          var _this2 = this;\n\n          providerRun('render').then(function () {\n            return pluginRun('render');\n          }).then(function () {\n            _this2.setState('ready', true).trigger('render').trigger('ready');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Load an item\n         *  - provider loadItem, resolve or return the itemData\n         *  - plugins loadItem\n         *  - call renderItem\n         * @param {*} itemRef - something that let you identify the item to load\n         * @fires runner#loaditem\n         * @returns {runner} chains\n         */\n        loadItem: function loadItem(itemRef) {\n          var _this3 = this;\n\n          providerRun('loadItem', itemRef).then(function (itemData) {\n            _this3.setItemState(itemRef, 'loaded', true).off('loaditem.internal').after('loaditem.internal', function () {\n              return _this3.renderItem(itemRef, itemData);\n            }).trigger('loaditem', itemRef, itemData);\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Render an item\n         *  - provider renderItem\n         *  - plugins renderItem\n         * @param {Object} itemRef\n         * @param {Object} itemData - the loaded item data\n         * @fires runner#renderitem\n         * @returns {runner} chains\n         */\n        renderItem: function renderItem(itemRef, itemData) {\n          var _this4 = this;\n\n          providerRun('renderItem', itemRef, itemData).then(function () {\n            _this4.setItemState(itemRef, 'ready', true).trigger('renderitem', itemRef, itemData);\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Unload an item (for example to destroy the item)\n         *  - provider unloadItem\n         *  - plugins unloadItem\n         * @param {*} itemRef - something that let you identify the item to unload\n         * @fires runner#unloaditem\n         * @returns {runner} chains\n         */\n        unloadItem: function unloadItem(itemRef) {\n          var _this5 = this;\n\n          providerRun('unloadItem', itemRef).then(function () {\n            itemStates = _.omit(itemStates, itemRef);\n\n            _this5.trigger('unloaditem', itemRef);\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Disable an item\n         *  - provider disableItem\n         * @param {*} itemRef - something that let you identify the item\n         * @fires runner#disableitem\n         * @returns {runner} chains\n         */\n        disableItem: function disableItem(itemRef) {\n          var _this6 = this;\n\n          if (!this.getItemState(itemRef, 'disabled')) {\n            providerRun('disableItem', itemRef).then(function () {\n              _this6.setItemState(itemRef, 'disabled', true).trigger('disableitem', itemRef);\n            }).catch(reportError);\n          }\n\n          return this;\n        },\n\n        /**\n         * Enable an item\n         *  - provider enableItem\n         * @param {*} itemRef - something that let you identify the item\n         * @fires runner#disableitem\n         * @returns {runner} chains\n         */\n        enableItem: function enableItem(itemRef) {\n          var _this7 = this;\n\n          if (this.getItemState(itemRef, 'disabled')) {\n            providerRun('enableItem', itemRef).then(function () {\n              _this7.setItemState(itemRef, 'disabled', false).trigger('enableitem', itemRef);\n            }).catch(reportError);\n          }\n\n          return this;\n        },\n\n        /**\n         * When the test is terminated\n         *  - provider finish\n         *  - plugins finsh\n         * @fires runner#finish\n         * @returns {runner} chains\n         */\n        finish: function finish() {\n          var _this8 = this;\n\n          providerRun('finish').then(function () {\n            return pluginRun('finish');\n          }).then(function () {\n            _this8.setState('finish', true).trigger('finish');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Flushes the runner\n         *  - provider flush\n         *  - plugins flush\n         * @fires runner#flush\n         * @returns {runner} chains\n         */\n        flush: function flush() {\n          var _this9 = this;\n\n          providerRun('flush').then(function () {\n            return pluginRun('flush');\n          }).then(function () {\n            _this9.setState('flush', true).trigger('flush');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Destroy\n         *  - provider destroy\n         *  - plugins destroy\n         * @fires runner#destroy\n         * @returns {runner} chains\n         */\n        destroy: function destroy() {\n          var _this10 = this;\n\n          providerRun('destroy').then(function () {\n            return pluginRun('destroy');\n          }).then(function () {\n            if (proxy) {\n              return proxy.destroy();\n            }\n          }).then(function () {\n            _this10.setTestContext({}).setTestMap({}).setState('destroy', true).trigger('destroy');\n          }).catch(reportError);\n          return this;\n        },\n\n        /**\n         * Get the whole test runner configuration\n         * @returns {Object} the config\n         */\n        getConfig: function getConfig() {\n          return config || {};\n        },\n\n        /**\n         * Get the options from the configuration parameters, (feature flags, parameter values, etc.)\n         *\n         * Alias to getConfig().options\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @returns {Object} the configuration options\n         */\n        getOptions: function getOptions() {\n          return this.getConfig().options || {};\n        },\n\n        /**\n         * Get the runner pugins\n         * @returns {plugin[]} the plugins\n         */\n        getPlugins: function getPlugins() {\n          return plugins;\n        },\n\n        /**\n         * Get a plugin\n         * @param {String} name - the plugin name\n         * @returns {plugin} the plugin\n         */\n        getPlugin: function getPlugin(name) {\n          return plugins[name];\n        },\n\n        /**\n         * Get the configuration of the plugins\n         *\n         * Alias to getConfig().options.plugins\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @returns {Object} the configuration options\n         */\n        getPluginsConfig: function getPluginsConfig() {\n          return this.getOptions().plugins || {};\n        },\n\n        /**\n         * Get the configuration of a given plugin\n         *\n         * In deprecated mode, this is initialized through getTestData (after /init)\n         *\n         * @param {String} pluginName - the name of the plugin\n         * @returns {Object} the configuration options of the plugin\n         */\n        getPluginConfig: function getPluginConfig(pluginName) {\n          if (pluginName && plugins[pluginName]) {\n            var pluginsConfig = this.getPluginsConfig();\n\n            if (pluginsConfig[pluginName]) {\n              return pluginsConfig[pluginName];\n            }\n          }\n\n          return {};\n        },\n\n        /**\n         * Get the area broker, load it if not present\n         *\n         * @returns {areaBroker} the areaBroker\n         */\n        getAreaBroker: function getAreaBroker() {\n          if (!areaBroker) {\n            areaBroker = provider.loadAreaBroker.call(this);\n          }\n\n          return areaBroker;\n        },\n\n        /**\n         * Get the proxy, load it if not present\n         *\n         * @returns {proxy} the proxy\n         */\n        getProxy: function getProxy() {\n          var _this11 = this;\n\n          if (!proxy) {\n            if (!_.isFunction(provider.loadProxy)) {\n              throw new Error('The provider does not have a loadProxy method');\n            }\n\n            proxy = provider.loadProxy.call(this);\n            proxy.on('error', function (error) {\n              return _this11.trigger('error', error);\n            });\n            proxy.install(this.getDataHolder());\n          }\n\n          return proxy;\n        },\n\n        /**\n         * Get the probeOverseer, and load it if not present\n         *\n         * @returns {probeOverseer} the probe overseer\n         */\n        getProbeOverseer: function getProbeOverseer() {\n          if (!probeOverseer && _.isFunction(provider.loadProbeOverseer)) {\n            probeOverseer = provider.loadProbeOverseer.call(this);\n          }\n\n          return probeOverseer;\n        },\n\n        /**\n         * Get the testStore, and load it if not present\n         *\n         * @returns {testStore} the testStore instance\n         */\n        getTestStore: function getTestStore() {\n          if (!testStore && _.isFunction(provider.loadTestStore)) {\n            testStore = provider.loadTestStore.call(this);\n          }\n\n          return testStore;\n        },\n\n        /**\n         * Get a plugin store.\n         * It's a convenience method that calls testStore.getStore\n         * @param {String} name - the name of store, usually the plugin name.\n         *\n         * @returns {Promise<storage>} the plugin store\n         */\n        getPluginStore: function getPluginStore(name) {\n          var loadedStore = this.getTestStore();\n\n          if (!loadedStore || !_.isFunction(loadedStore.getStore)) {\n            return Promise.reject(new Error('Please configure a testStore via loadTestStore to be able to get a plugin store'));\n          }\n\n          return this.getTestStore().getStore(name);\n        },\n\n        /**\n         * Check a runner state\n         *\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         */\n        getState: function getState(name) {\n          return !!states[name];\n        },\n\n        /**\n         * Define a runner state\n         *\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {runner} chains\n         * @throws {TypeError} if the state name is not a valid string\n         */\n        setState: function setState(name, active) {\n          if (!_.isString(name) || _.isEmpty(name)) {\n            throw new TypeError('The state must have a name');\n          }\n\n          states[name] = !!active;\n          return this;\n        },\n\n        /**\n         * Checks a runner persistent state\n         *  - provider getPersistentState\n         *\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         */\n        getPersistentState: function getPersistentState(name) {\n          var state;\n\n          if (_.isFunction(provider.getPersistentState)) {\n            state = provider.getPersistentState.call(runner, name);\n          }\n\n          return !!state;\n        },\n\n        /**\n         * Defines a runner persistent state\n         *  - provider setPersistentState\n         *\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {Promise} Returns a promise that:\n         *                      - will be resolved once the state is fully stored\n         *                      - will be rejected if any error occurs or if the state name is not a valid string\n         */\n        setPersistentState: function setPersistentState(name, active) {\n          var stored;\n\n          if (!_.isString(name) || _.isEmpty(name)) {\n            stored = Promise.reject(new TypeError('The state must have a name'));\n          } else {\n            stored = providerRun('setPersistentState', name, !!active);\n          }\n\n          stored.catch(reportError);\n          return stored;\n        },\n\n        /**\n         * Check an item state\n         *\n         * @param {*} itemRef - something that let you identify the item\n         * @param {String} name - the state name\n         * @returns {Boolean} if active, false if not set\n         *\n         * @throws {TypeError} if there is no itemRef nor name\n         */\n        getItemState: function getItemState(itemRef, name) {\n          if (_.isEmpty(itemRef) || _.isEmpty(name)) {\n            throw new TypeError('The state is identified by an itemRef and a name');\n          }\n\n          return !!(itemStates[itemRef] && itemStates[itemRef][name]);\n        },\n\n        /**\n         * Check an item state\n         *\n         * @param {*} itemRef - something that let you identify the item\n         * @param {String} name - the state name\n         * @param {Boolean} active - is the state active\n         * @returns {runner} chains\n         *\n         * @throws {TypeError} if there is no itemRef nor name\n         */\n        setItemState: function setItemState(itemRef, name, active) {\n          if (_.isEmpty(itemRef) || _.isEmpty(name)) {\n            throw new TypeError('The state is identified by an itemRef and a name');\n          }\n\n          itemStates[itemRef] = itemStates[itemRef] || {\n            loaded: false,\n            ready: false,\n            disabled: false\n          };\n          itemStates[itemRef][name] = !!active;\n          return this;\n        },\n\n        /**\n         * Get the test data/definition\n         * @deprecated\n         * @returns {Object} the test data\n         */\n        getTestData: function getTestData() {\n          return dataHolder && dataHolder.get('testData');\n        },\n\n        /**\n         * Set the test data/definition\n         * @deprecated\n         * @param {Object} testData - the test data\n         * @returns {runner} chains\n         */\n        setTestData: function setTestData(testData) {\n          if (dataHolder && _.isPlainObject(testData)) {\n            dataHolder.set('testData', testData);\n          }\n\n          return this;\n        },\n\n        /**\n         * Get the test context/state\n         * @returns {Object} the test context\n         */\n        getTestContext: function getTestContext() {\n          return dataHolder && dataHolder.get('testContext');\n        },\n\n        /**\n         * Set the test context/state\n         * @param {Object} testContext - the context to set\n         * @returns {runner} chains\n         */\n        setTestContext: function setTestContext(testContext) {\n          if (dataHolder && _.isPlainObject(testContext)) {\n            dataHolder.set('testContext', testContext);\n          }\n\n          return this;\n        },\n\n        /**\n         * Get the test items map\n         * @returns {Object} the test map\n         */\n        getTestMap: function getTestMap() {\n          return dataHolder && dataHolder.get('testMap');\n        },\n\n        /**\n         * Set the test items map\n         * @param {Object} testMap - the map to set\n         * @returns {runner} chains\n         */\n        setTestMap: function setTestMap(testMap) {\n          if (dataHolder && _.isPlainObject(testMap)) {\n            dataHolder.set('testMap', testMap);\n          }\n\n          return this;\n        },\n\n        /**\n         * Get the data holder\n         * @returns {dataHolder}\n         */\n        getDataHolder: function getDataHolder() {\n          if (!dataHolder) {\n            if (_.isFunction(provider.loadDataHolder)) {\n              dataHolder = provider.loadDataHolder.call(this);\n            } else {\n              dataHolder = dataHolderFactory();\n            }\n          }\n\n          return dataHolder;\n        },\n\n        /**\n         * Move next alias\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        next: function next(scope) {\n          if (_.isFunction(provider.next)) {\n            return providerRun('next', scope);\n          } //backward compat\n\n\n          this.trigger('move', 'next', scope);\n          return this;\n        },\n\n        /**\n         * Move previous alias\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        previous: function previous(scope) {\n          if (_.isFunction(provider.previous)) {\n            return providerRun('previous', scope);\n          } //backward compat\n\n\n          this.trigger('move', 'previous', scope);\n          return this;\n        },\n\n        /**\n         * Move to alias\n         * @param {String|Number} position - where to jump\n         * @param {String|*} [scope] - the movement scope\n         * @fires runner#move\n         * @returns {runner} chains\n         */\n        jump: function jump(position, scope) {\n          if (_.isFunction(provider.jump)) {\n            return providerRun('jump', position, scope);\n          } //backward compat\n\n\n          this.trigger('move', 'jump', scope, position);\n          return this;\n        },\n\n        /**\n         * Skip alias\n         * @param {String|*} [scope] - the movement scope\n         * @param {String|*} [direction] - next/previous/jump\n         * @param {Number|*} [ref] - the item ref\n         * @fires runner#skip\n         * @returns {runner} chains\n         */\n        skip: function skip(scope, direction, ref) {\n          if (_.isFunction(provider.skip)) {\n            return providerRun('skip', scope, direction, ref);\n          } //backward compat\n\n\n          this.trigger('skip', scope, direction, ref);\n          return this;\n        },\n\n        /**\n         * Exit the test\n         * @param {String|*} [why] - reason the test is exited\n         * @fires runner#exit\n         * @returns {runner} chains\n         */\n        exit: function exit(why) {\n          if (_.isFunction(provider.exit)) {\n            return providerRun('exit', why);\n          } //backward compat\n\n\n          this.trigger('exit', why);\n          return this;\n        },\n\n        /**\n         * Pause the current execution\n         * @fires runner#pause\n         * @returns {runner} chains\n         */\n        pause: function pause() {\n          if (_.isFunction(provider.pause)) {\n            if (!this.getState('pause')) {\n              this.setState('pause', true);\n              return providerRun('pause');\n            }\n\n            return Promise.resolve();\n          } //backward compat\n\n\n          if (!this.getState('pause')) {\n            this.setState('pause', true).trigger('pause');\n          }\n\n          return this;\n        },\n\n        /**\n         * Resume a paused test\n         * @fires runner#pause\n         * @returns {runner} chains\n         */\n        resume: function resume() {\n          if (_.isFunction(provider.resume)) {\n            if (this.getState('pause')) {\n              this.setState('pause', false);\n              return providerRun('resume');\n            }\n\n            return Promise.resolve();\n          } //backward compat\n\n\n          if (this.getState('pause') === true) {\n            this.setState('pause', false).trigger('resume');\n          }\n\n          return this;\n        },\n\n        /**\n         * Notify a test timeout\n         * @param {String} scope - The scope where the timeout occurred\n         * @param {String} ref - The reference to the place where the timeout occurred\n         * @param {Object} [timer] - The timer's descriptor, if any\n         * @fires runner#timeout\n         * @returns {runner} chains\n         */\n        timeout: function timeout(scope, ref, timer) {\n          if (_.isFunction(provider.timeout)) {\n            return providerRun('timeout', scope, ref, timer);\n          } //backward compat\n\n\n          this.trigger('timeout', scope, ref, timer);\n          return this;\n        }\n      });\n      runner.on('move', function () {\n        this.trigger.apply(this, arguments);\n      }).after('destroy', function destroyCleanUp() {\n        if (dataHolder) {\n          dataHolder.clear();\n        }\n\n        areaBroker = null;\n        proxy = null;\n        probeOverseer = null;\n        testStore = null;\n      });\n      return runner;\n    } //bind the provider registration capabilities to the testRunnerFactory\n\n\n    var runner = providerRegistry(testRunnerFactory, function validateProvider(provider) {\n      //mandatory methods\n      if (!_.isFunction(provider.loadAreaBroker)) {\n        throw new TypeError('The runner provider MUST have a method that returns an areaBroker');\n      }\n\n      return true;\n    });\n\n    return runner;\n\n});\n\n","define('taoTests/runner/proxy',['lodash', 'async', 'core/delegator', 'core/eventifier', 'core/providerRegistry', 'core/tokenHandler', 'core/connectivity'], function (_, async, delegator, eventifier, providerRegistry, tokenHandlerFactory, connectivity) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    async = async && Object.prototype.hasOwnProperty.call(async, 'default') ? async['default'] : async;\n    delegator = delegator && Object.prototype.hasOwnProperty.call(delegator, 'default') ? delegator['default'] : delegator;\n    eventifier = eventifier && Object.prototype.hasOwnProperty.call(eventifier, 'default') ? eventifier['default'] : eventifier;\n    providerRegistry = providerRegistry && Object.prototype.hasOwnProperty.call(providerRegistry, 'default') ? providerRegistry['default'] : providerRegistry;\n    tokenHandlerFactory = tokenHandlerFactory && Object.prototype.hasOwnProperty.call(tokenHandlerFactory, 'default') ? tokenHandlerFactory['default'] : tokenHandlerFactory;\n    connectivity = connectivity && Object.prototype.hasOwnProperty.call(connectivity, 'default') ? connectivity['default'] : connectivity;\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n    var _defaults = {};\n    var _slice = [].slice;\n    /**\n     * Defines a proxy bound to a particular adapter\n     *\n     * @param {String} proxyName - The name of the proxy adapter to use in the returned proxy instance\n     * @param {Object} [config] - Some optional config depending of implementation,\n     *                            this object will be forwarded to the proxy adapter\n     * @returns {proxy} - The proxy instance, bound to the selected proxy adapter\n     */\n\n    function proxyFactory(proxyName, config) {\n      var proxy, delegateProxy, communicator, communicatorPromise;\n      var testDataHolder;\n      var extraCallParams = {};\n      var proxyAdapter = proxyFactory.getProvider(proxyName);\n\n      var initConfig = _.defaults(config || {}, _defaults);\n\n      var tokenHandler = tokenHandlerFactory();\n      var middlewares = {};\n      var initialized = false;\n      var onlineStatus = connectivity.isOnline();\n      /**\n       * Gets parameters merged with extra parameters\n       * @param {Object} [params]\n       * @returns {Object}\n       */\n\n      function getParams(params) {\n        var mergedParams = _.merge({}, params, extraCallParams);\n\n        extraCallParams = {};\n        return mergedParams;\n      }\n      /**\n       * Gets the aggregated list of middlewares for a particular queue name\n       * @param {String} queue - The name of the queue to get\n       * @returns {Array}\n       */\n\n\n      function getMiddlewares(queue) {\n        var list = middlewares[queue] || [];\n\n        if (middlewares.all) {\n          list = list.concat(middlewares.all);\n        }\n\n        return list;\n      }\n      /**\n       * Applies the list of registered middlewares onto the received response\n       * @param {Object} request - The request descriptor\n       * @param {String} request.command - The name of the requested command\n       * @param {Object} request.params - The map of provided parameters\n       * @param {Object} response The response descriptor\n       * @param {String} response.status The status of the response, can be either 'success' or 'error'\n       * @param {Object} response.data The full response data\n       * @returns {Promise}\n       */\n\n\n      function applyMiddlewares(request, response) {\n        // wrap each middleware to provide parameters\n        var list = _.map(getMiddlewares(request.command), function (middleware) {\n          return function (next) {\n            middleware(request, response, next);\n          };\n        }); // apply each middleware in series, then resolve or reject the promise\n\n\n        return new Promise(function (resolve, reject) {\n          async.series(list, function (err) {\n            // handle implicit error from response descriptor\n            if (!err && 'error' === response.status) {\n              err = response.data;\n            }\n\n            if (err) {\n              reject(err);\n            } else {\n              proxy.trigger('receive', response.data, 'proxy');\n              resolve(response.data);\n            }\n          });\n        });\n      }\n      /**\n       * Delegates the call to the proxy implementation and apply the middleware.\n       *\n       * @param {String} fnName - The name of the delegated method to call\n       * @returns {Promise} - The delegated method must return a promise\n       * @private\n       * @throws Error\n       */\n\n\n      function delegate(fnName) {\n        var request = {\n          command: fnName,\n          params: _slice.call(arguments, 1)\n        };\n\n        if (!initialized && !_.contains(['install', 'init'], fnName)) {\n          return Promise.reject(new Error('Proxy is not properly initialized or has been destroyed!'));\n        }\n\n        return delegateProxy.apply(null, arguments).then(function (data) {\n          // If the delegate call succeed the proxy is initialized.\n          // Place this set here to avoid to wrap the init() into another promise.\n          initialized = true; // handle successful request\n\n          return applyMiddlewares(request, {\n            status: 'success',\n            data: data\n          });\n        }).catch(function (data) {\n          // handle failed request\n          return applyMiddlewares(request, {\n            status: 'error',\n            data: data\n          });\n        });\n      }\n      /**\n       * Defines the test runner proxy\n       * @typedef {proxy}\n       */\n\n\n      proxy = eventifier({\n        /**\n         * Add a middleware\n         * @param {String} [command] The command queue in which add the middleware (default: 'all')\n         * @param {Function...} callback - A middleware callback. Must accept 3 parameters: request, response, next.\n         * @returns {proxy}\n         */\n        use: function use(command) {\n          var queue = command && _.isString(command) ? command : 'all';\n          var list = middlewares[queue] || [];\n          middlewares[queue] = list;\n\n          _.each(arguments, function (cb) {\n            if (_.isFunction(cb)) {\n              list.push(cb);\n            }\n          });\n\n          return this;\n        },\n\n        /**\n         * Install the proxy.\n         * This step let's attach some features before the proxy reallys starts (before init).\n         *\n         * @param {Map} dataHolder - the test runner data holder\n         * @returns {*}\n         */\n        install: function install(dataHolder) {\n          if (dataHolder) {\n            testDataHolder = dataHolder;\n          }\n\n          return delegate('install', initConfig);\n        },\n\n        /**\n         * Initializes the proxy\n         * @param {Object} [params] - An optional list of parameters\n         * @returns {Promise} - Returns a promise. The proxy will be fully initialized on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires init\n         */\n        init: function init(params) {\n          /**\n           * @event proxy#init\n           * @param {Promise} promise\n           * @param {Object} config\n           * @param {Object} params\n           */\n          return delegate('init', initConfig, getParams(params));\n        },\n\n        /**\n         * Uninstalls the proxy\n         * @returns {Promise} - Returns a promise. The proxy will be fully uninstalled on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires destroy\n         */\n        destroy: function destroy() {\n          /**\n           * @event proxy#destroy\n           * @param {Promise} promise\n           */\n          return delegate('destroy').then(function () {\n            // The proxy is now destroyed. A call to init() is mandatory to be able to use it again.\n            initialized = false; // a communicator has been invoked and...\n\n            if (communicatorPromise) {\n              return new Promise(function (resolve, reject) {\n                function destroyCommunicator() {\n                  communicator.destroy().then(resolve).catch(reject);\n                }\n\n                communicatorPromise // ... has been loaded successfully, then destroy it\n                .then(function () {\n                  destroyCommunicator();\n                }) // ...has failed to be loaded, maybe no need to destroy it\n                .catch(function () {\n                  if (communicator) {\n                    destroyCommunicator();\n                  } else {\n                    resolve();\n                  }\n                });\n              });\n            }\n          });\n        },\n\n        /**\n         * Get the map that holds the test data\n         * @returns {Map|Object} the dataHolder\n         */\n        getDataHolder: function getDataHolder() {\n          return testDataHolder;\n        },\n\n        /**\n         * Set the proxy as online\n         * @returns {proxy} chains\n         * @fires {proxy#reconnect}\n         */\n        setOnline: function setOnline() {\n          if (this.isOffline()) {\n            onlineStatus = true;\n            this.trigger('reconnect');\n          }\n\n          return this;\n        },\n\n        /**\n         * Set the proxy as offline\n         * @param {String} [source] - source of the connectivity change\n         * @returns {proxy} chains\n         * @fires {proxy#disconnect}\n         */\n        setOffline: function setOffline(source) {\n          if (this.isOnline()) {\n            onlineStatus = false;\n            this.trigger('disconnect', source);\n          }\n\n          return this;\n        },\n\n        /**\n         * Are we online ?\n         * @returns {Boolean}\n         */\n        isOnline: function isOnline() {\n          return onlineStatus;\n        },\n\n        /**\n         * Are we offline\n         * @returns {Boolean}\n         */\n        isOffline: function isOffline() {\n          return !onlineStatus;\n        },\n\n        /**\n         * For the proxy a connection error is an error object with\n         * source 'network', a 0 code and a false sent attribute.\n         *\n         * @param {Error|Object} err - the error to verify\n         * @returns {Boolean} true if a connection error.\n         */\n        isConnectivityError: function isConnectivityError(err) {\n          return _.isObject(err) && err.source === 'network' && err.code === 0 && err.sent === false;\n        },\n\n        /**\n         * Gets the security token handler\n         * @returns {tokenHandler}\n         */\n        getTokenHandler: function getTokenHandler() {\n          return tokenHandler;\n        },\n\n        /**\n         * Checks if a communication channel has been requested.\n         * @returns {Boolean}\n         */\n        hasCommunicator: function hasCommunicator() {\n          return !!communicatorPromise;\n        },\n\n        /**\n         * Gets access to the communication channel, load it if not present\n         * @returns {Promise} Returns a promise that will resolve the communication channel\n         */\n        getCommunicator: function getCommunicator() {\n          var self = this;\n\n          if (!initialized) {\n            return Promise.reject(new Error('Proxy is not properly initialized or has been destroyed!'));\n          }\n\n          if (!communicatorPromise) {\n            communicatorPromise = new Promise(function (resolve, reject) {\n              if (_.isFunction(proxyAdapter.loadCommunicator)) {\n                communicator = proxyAdapter.loadCommunicator.call(self);\n\n                if (communicator) {\n                  communicator.before('error', function (e, err) {\n                    if (self.isConnectivityError(err)) {\n                      self.setOffline('communicator');\n                    }\n                  }).on('error', function (err) {\n                    self.trigger('error', err);\n                  }).on('receive', function (response) {\n                    self.setOnline();\n                    self.trigger('receive', response, 'communicator');\n                  }).init().then(function () {\n                    return communicator.open().then(function () {\n                      resolve(communicator);\n                    }).catch(reject);\n                  }).catch(reject);\n                } else {\n                  reject(new Error('No communicator has been set up!'));\n                }\n              } else {\n                reject(new Error('The proxy provider does not have a loadCommunicator method'));\n              }\n            });\n          }\n\n          return communicatorPromise;\n        },\n\n        /**\n         * Registers a listener on a particular channel\n         * @param {String} name - The name of the channel to listen\n         * @param {Function} handler - The listener callback\n         * @returns {proxy}\n         * @throws TypeError if the name is missing or the handler is not a callback\n         */\n        channel: function channel(name, handler) {\n          if (!_.isString(name) || name.length <= 0) {\n            throw new TypeError('A channel must have a name');\n          }\n\n          if (!_.isFunction(handler)) {\n            throw new TypeError('A handler must be attached to a channel');\n          }\n\n          this.getCommunicator().then(function (communicatorInstance) {\n            communicatorInstance.channel(name, handler);\n          }) // just an empty catch to avoid any error to be displayed in the console when the communicator is not enabled\n          .catch(_.noop);\n          this.on(\"channel-\".concat(name), handler);\n          return this;\n        },\n\n        /**\n         * Sends an messages through the communication implementation.\n         * @param {String} channel - The name of the communication channel to use\n         * @param {Object} message - The message to send\n         * @returns {Promise} The delegated provider's method must return a promise\n         */\n        send: function send(channel, message) {\n          return this.getCommunicator().then(function (communicatorInstance) {\n            return communicatorInstance.send(channel, message);\n          });\n        },\n\n        /**\n         * Add extra parameters that will be added to the init or the next callTestAction or callItemAction\n         * This enables plugins to place parameters for next calls\n         * @param {Object} params - the extra parameters\n         * @returns {proxy}\n         */\n        addCallActionParams: function addCallActionParams(params) {\n          if (_.isPlainObject(params)) {\n            _.merge(extraCallParams, params);\n          }\n\n          return this;\n        },\n\n        /**\n         * Gets the test definition data\n         * @deprecated\n         *\n         * @returns {Promise} - Returns a promise. The test definition data will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires getTestData\n         */\n        getTestData: function getTestData() {\n          /**\n           * @event proxy#getTestData\n           * @param {Promise} promise\n           */\n          return delegate('getTestData');\n        },\n\n        /**\n         * Gets the test context\n         * @returns {Promise} - Returns a promise. The context object will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         */\n        getTestContext: function getTestContext() {\n          /**\n           * @event proxy#getTestContext\n           * @param {Promise} promise\n           */\n          return delegate('getTestContext');\n        },\n\n        /**\n         * Gets the test map\n         * @returns {Promise} - Returns a promise. The test map object will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         */\n        getTestMap: function getTestMap() {\n          /**\n           * @event proxy#getTestMap\n           * @param {Promise} promise\n           */\n          return delegate('getTestMap');\n        },\n\n        /**\n         * Sends the test variables\n         * @param {Object} variables\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later (default: false).\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires sendVariables\n         */\n        sendVariables: function sendVariables(variables, deferred) {\n          /**\n           * @event proxy#sendVariables\n           * @param {Promise} promise\n           */\n          return delegate('sendVariables', variables, deferred);\n        },\n\n        /**\n         * Calls an action related to the test\n         * @param {String} action - The name of the action to call\n         * @param {Object} [params] - Some optional parameters to join to the call\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later.\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires callTestAction\n         */\n        callTestAction: function callTestAction(action, params, deferred) {\n          /**\n           * @event proxy#callTestAction\n           * @param {Promise} promise\n           * @param {String} action\n           * @param {Object} params\n           */\n          return delegate('callTestAction', action, getParams(params), deferred);\n        },\n\n        /**\n         * Gets an item definition by its URI, also gets its current state\n         * @param {String} uri - The URI of the item to get\n         * @param {Object} [params] - addtional params to be appended\n         * @returns {Promise} - Returns a promise. The item data will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires getItem\n         */\n        getItem: function getItem(uri, params) {\n          /**\n           * @event proxy#getItem\n           * @param {Promise} promise\n           * @param {String} uri\n           */\n          return delegate('getItem', uri, params);\n        },\n\n        /**\n         * Submits the state and the response of a particular item\n         * @param {String} uri - The URI of the item to update\n         * @param {Object} state - The state to submit\n         * @param {Object} response - The response object to submit\n         * @param {Object} [params] - addtional params to be appended\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires submitItem\n         */\n        submitItem: function submitItem(uri, state, response, params) {\n          /**\n           * @event proxy#submitItem\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {Object} state\n           * @param {Object} response\n           */\n          return delegate('submitItem', uri, state, response, getParams(params));\n        },\n\n        /**\n         * Calls an action related to a particular item\n         * @param {String} uri - The URI of the item for which call the action\n         * @param {String} action - The name of the action to call\n         * @param {Object} [params] - Some optional parameters to join to the call\n         * @param {Boolean} deferred whether action can be scheduled (put into queue) to be sent in a bunch of actions later.\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires callItemAction\n         */\n        callItemAction: function callItemAction(uri, action, params, deferred) {\n          /**\n           * @event proxy#callItemAction\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {String} action\n           * @param {Object} params\n           */\n          return delegate('callItemAction', uri, action, getParams(params), deferred);\n        },\n\n        /**\n         * Sends a telemetry signal\n         * @param {String} uri - The URI of the item for which sends the telemetry signal\n         * @param {String} signal - The name of the signal to send\n         * @param {Object} [params] - Some optional parameters to join to the signal\n         * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n         *                      Any error will be provided if rejected.\n         * @fires telemetry\n         */\n        telemetry: function telemetry(uri, signal, params) {\n          /**\n           * @event proxy#telemetry\n           * @param {Promise} promise\n           * @param {String} uri\n           * @param {String} signal\n           * @param {Object} params\n           */\n          return delegate('telemetry', uri, signal, params);\n        }\n      }); //listen for connectivty changes\n\n      connectivity.on('offline', function () {\n        proxy.setOffline('device');\n      }).on('online', function () {\n        proxy.setOnline();\n      }); // catch platform messages that come outside of the communicator component, then each is dispatched to the right channel\n\n      proxy.on('message', function (channel, message) {\n        this.trigger(\"channel-\".concat(channel), message);\n      }).use(function (request, response, next) {\n        if (response.data && response.data.messages) {\n          // receive server messages\n          _.forEach(response.data.messages, function (msg) {\n            if (msg.channel) {\n              proxy.trigger('message', msg.channel, msg.message);\n            } else {\n              proxy.trigger('message', 'malformed', msg);\n            }\n          });\n        }\n\n        next();\n      }) //detect failing request and change the online status\n      .use(function (request, response, next) {\n        if (proxy.isConnectivityError(response.data)) {\n          proxy.setOffline('request');\n        } else if (response.data && response.data.sent === true) {\n          proxy.setOnline();\n        }\n\n        next();\n      });\n      delegateProxy = delegator(proxy, proxyAdapter, {\n        name: 'proxy',\n        wrapper: function pluginWrapper(response) {\n          return Promise.resolve(response);\n        }\n      });\n      return proxy;\n    }\n\n    var proxy = providerRegistry(proxyFactory);\n\n    return proxy;\n\n});\n\n","define('taoTests/runner/providerLoader',['core/logger', 'core/providerLoader', 'core/pluginLoader', 'core/communicator', 'taoTests/runner/runner', 'taoTests/runner/proxy', 'taoItems/runner/api/itemRunner'], function (loggerFactory, providerLoader, pluginLoader, _communicator, _runner, _proxy, _itemRunner) { 'use strict';\n\n  loggerFactory = loggerFactory && Object.prototype.hasOwnProperty.call(loggerFactory, 'default') ? loggerFactory['default'] : loggerFactory;\n  providerLoader = providerLoader && Object.prototype.hasOwnProperty.call(providerLoader, 'default') ? providerLoader['default'] : providerLoader;\n  pluginLoader = pluginLoader && Object.prototype.hasOwnProperty.call(pluginLoader, 'default') ? pluginLoader['default'] : pluginLoader;\n  _communicator = _communicator && Object.prototype.hasOwnProperty.call(_communicator, 'default') ? _communicator['default'] : _communicator;\n  _runner = _runner && Object.prototype.hasOwnProperty.call(_runner, 'default') ? _runner['default'] : _runner;\n  _proxy = _proxy && Object.prototype.hasOwnProperty.call(_proxy, 'default') ? _proxy['default'] : _proxy;\n  _itemRunner = _itemRunner && Object.prototype.hasOwnProperty.call(_itemRunner, 'default') ? _itemRunner['default'] : _itemRunner;\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var logger = loggerFactory('taoTests/runner/loader');\n  /**\n   * @typedef {Object} provider - A provider is an object exposing a list of methods with respect to the API managed by the target.\n   * @property {String} name - The name of the provider. It should be unique among all.\n   * @property {Function} init - Each provider much expose at least a method `init()`\n   * @property {Function} ... - Any other method the target is expecting\n   */\n\n  /**\n   * Load the providers that match the registration\n   * @param {Object} providers\n   * @param {provider|provider[]} providers.runner\n   * @param {provider|provider[]} [providers.proxy]\n   * @param {provider|provider[]} [providers.communicator]\n   * @param {provider|provider[]} [providers.plugins]\n   * @param {Boolean} loadFromBundle - does the loader load the modules from the sources (dev mode) or the bundles\n   * @returns {Promise<Object>} resolves with the loaded providers per provider type\n   */\n\n  function loadTestRunnerProviders() {\n    var providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var loadFromBundle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    /**\n     * Default way to load the modules and register the providers\n     * @param {Object[]} providersToLoad - the list of providers\n     * @param {Object} target - a provider target (an object that use the providers), it needs to expose registerProvider\n     * @returns {Promise<Object>} resolves with the target\n     * @throws {TypeError} if the target is not a provider target\n     */\n    var loadAndRegisterProvider = function loadAndRegisterProvider() {\n      var providersToLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var target = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!target || typeof target.registerProvider !== 'function') {\n        throw new TypeError('Trying to register providers on a target that is not a provider API');\n      }\n\n      return providerLoader().addList(providersToLoad).load(loadFromBundle).then(function (loadedProviders) {\n        loadedProviders.forEach(function (provider) {\n          return target.registerProvider(provider.name, provider);\n        });\n        return target;\n      });\n    };\n    /**\n     * Available provider registration\n     */\n\n\n    var registration = {\n      runner: function runner() {\n        var runnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return loadAndRegisterProvider(runnerProviders, _runner);\n      },\n      itemRunner: function itemRunner() {\n        var itemRunnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return providerLoader().addList(itemRunnerProviders).load(loadFromBundle).then(function (loadedProviders) {\n          loadedProviders.forEach(function (provider) {\n            return _itemRunner.register(provider.name, provider);\n          });\n          return _itemRunner;\n        });\n      },\n      communicator: function communicator() {\n        var communicatorProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return loadAndRegisterProvider(communicatorProviders, _communicator);\n      },\n      proxy: function proxy() {\n        var proxyProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return loadAndRegisterProvider(proxyProviders, _proxy);\n      },\n      plugins: function plugins() {\n        var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        return pluginLoader().addList(plugins).load(loadFromBundle);\n      }\n    };\n\n    if (!loadFromBundle) {\n      logger.warn('All modules will be loaded from sources');\n    }\n\n    return Promise.all(Object.keys(providers).map(function (providerType) {\n      if (typeof registration[providerType] === 'function') {\n        logger.debug(\"Start to load and register the '\".concat(providerType, \"' providers\"));\n        var providersToLoad = Array.isArray(providers[providerType]) ? providers[providerType] : [providers[providerType]];\n        return registration[providerType](providersToLoad).then(function (loaded) {\n          logger.debug(\"'\".concat(providerType, \"' providers are loaded and registered\"));\n          return _defineProperty({}, providerType, loaded);\n        });\n      } else {\n        logger.warn(\"Ignoring the '\".concat(providerType, \"' providers loading, no registration method found\"));\n      }\n    })).then(function (results) {\n      return results.reduce(function (acc, value) {\n        return Object.assign(acc, value);\n      }, {});\n    }).catch(function (err) {\n      logger.error(\"Error in test runner providers and plugins loading : \".concat(err.message));\n      throw err;\n    });\n  }\n\n  return loadTestRunnerProviders;\n\n});\n\n","define('taoTests/runner/proxy/sample',[],function () { 'use strict';\n\n    /**\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2016-2019 (original work) Open Assessment Technologies SA ;\n     */\n\n    /**\n     * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>\n     */\n\n    /**\n     * Sample proxy definition\n     * @type {Object}\n     */\n    var sampleProxy = {\n      /**\n       * Initializes the proxy\n       * @returns {Promise} - Returns a promise. The proxy will be fully initialized on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      init: function init() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // do initialisation\n          // once the proxy has been fully initialized notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Uninstalls the proxy\n       * @returns {Promise} - Returns a promise. The proxy will be fully uninstalled on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      destroy: function destroy() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // do uninstall actions\n          // once the proxy has been fully uninstalled notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets the test definition data\n       * @param {Object} config - The config provided to the proxy factory\n       * @returns {Promise} - Returns a promise. The test definition data will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      getTestData: function getTestData() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the test definition data\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets the test context\n       * @returns {Promise} - Returns a promise. The context object will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      getTestContext: function getTestContext() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the test context object\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Calls an action related to the test\n       * @param {String} action - The name of the action to call\n       * @param {Object} [params] - Some optional parameters to join to the call\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      callTestAction: function callTestAction() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // call the action\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Gets an item definition by its URI, also gets its current state\n       * @param {String} uri - The URI of the item to get\n       * @returns {Promise} - Returns a promise. The item data will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires getItem\n       */\n      getItem: function getItem() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // get the definition data and the state of the item\n          // once the item data is loaded provide the data by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Submits the state and the response of a particular item\n       * @param {String} uri - The URI of the item to update\n       * @param {Object} state - The state to submit\n       * @param {Object} response - The response object to submit\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires submitItem\n       */\n      submitItem: function submitItem() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // submit the state and the response of the item\n          // once the data has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Calls an action related to a particular item\n       * @param {String} uri - The URI of the item for which call the action\n       * @param {String} action - The name of the action to call\n       * @param {Object} [params] - Some optional parameters to join to the call\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       */\n      callItemAction: function callItemAction() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // call the action\n          // once the action has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      },\n\n      /**\n       * Sends a telemetry signal\n       * @param {String} uri - The URI of the item for which sends the telemetry signal\n       * @param {String} signal - The name of the signal to send\n       * @param {Object} [params] - Some optional parameters to join to the signal\n       * @returns {Promise} - Returns a promise. The result of the request will be provided on resolve.\n       *                      Any error will be provided if rejected.\n       * @fires telemetry\n       */\n      telemetry: function telemetry() {\n        // the method must return a promise\n        return new Promise(function (resolve) {\n          // send the signal\n          // once the signal has been processed notify the success by resolving the promise\n          resolve(); // you can also notify error by rejecting the promise\n          // reject(error);\n        });\n      }\n    };\n\n    return sampleProxy;\n\n});\n\n","define('taoTests/runner/runnerComponent',['lodash', 'ui/component', 'taoTests/runner/runner', 'taoTests/runner/providerLoader', 'handlebars'], function (_, component, runnerFactory, providerLoader, Handlebars) { 'use strict';\n\n  _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n  component = component && Object.prototype.hasOwnProperty.call(component, 'default') ? component['default'] : component;\n  runnerFactory = runnerFactory && Object.prototype.hasOwnProperty.call(runnerFactory, 'default') ? runnerFactory['default'] : runnerFactory;\n  providerLoader = providerLoader && Object.prototype.hasOwnProperty.call(providerLoader, 'default') ? providerLoader['default'] : providerLoader;\n  Handlebars = Handlebars && Object.prototype.hasOwnProperty.call(Handlebars, 'default') ? Handlebars['default'] : Handlebars;\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n\n  var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {\n    this.compilerInfo = [4,'>= 1.0.0'];\n  helpers = this.merge(helpers, Handlebars.helpers);  \n\n\n    return \"<div class=\\\"runner-component\\\"></div>\\n\";\n    });\n  function runnerComponentTpl(data, options, asString) {\n    var html = Template(data, options);\n    return (asString || true) ? html : $(html);\n  }\n\n  /**\n   * Validate required options from the configuration\n   * @param {Object} config\n   * @returns {Boolean} true if valid\n   * @throws {TypeError} in case of validation failure\n   */\n\n  function validateTestRunnerConfiguration() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var requiredProperties = ['providers', 'options', 'serviceCallId'];\n\n    if (_typeof(config) !== 'object') {\n      throw new TypeError(\"The runner configuration must be an object, '\".concat(_typeof(config), \"' received\"));\n    }\n\n    if (requiredProperties.some(function (property) {\n      return typeof config[property] === 'undefined';\n    })) {\n      throw new TypeError(\"The runner configuration must contains at least the following properties : \".concat(requiredProperties.join(',')));\n    }\n\n    return true;\n  }\n  /**\n   * Get the selected provider if set or infer it from the providers list\n   * @param {String} type - the type of provider (runner, communicator, proxy, etc.)\n   * @param {Object} config\n   * @returns {String} the selected provider for the given type\n   */\n\n\n  function getSelectedProvider() {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'runner';\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (config.provider && config.provider[type]) {\n      return config.provider[type];\n    }\n\n    if (config.providers && config.providers[type]) {\n      var typeProviders = config.providers[type];\n\n      if (_typeof(typeProviders) === 'object' && (typeProviders.id || typeProviders.name)) {\n        return typeProviders.id || typeProviders.name;\n      }\n\n      if (Array.isArray(typeProviders) && typeProviders.length > 0) {\n        return typeProviders[0].id || typeProviders[0].name;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Wraps a test runner into a component\n   * @param {jQuery|HTMLElement|String} container - The container in which renders the component\n   * @param {Object} config - The component configuration options\n   * @param {String} config.serviceCallId - The identifier of the test session\n   * @param {Object} config.providers\n   * @param {Object} config.options\n   * @param {Boolean} [config.loadFromBundle=false] - do we load the modules from the bundles\n   * @param {Boolean} [config.replace] - When the component is appended to its container, clears the place before\n   * @param {Number|String} [config.width] - The width in pixels, or 'auto' to use the container's width\n   * @param {Number|String} [config.height] - The height in pixels, or 'auto' to use the container's height\n   * @param {Function} [template] - An optional template for the component\n   * @returns {runnerComponent}\n   */\n\n\n  function runnerComponentFactory() {\n    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var template = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : runnerComponentTpl;\n    var runner = null;\n    var plugins = [];\n\n    if (!container) {\n      throw new TypeError('A container element must be defined to contain the runnerComponent');\n    }\n\n    validateTestRunnerConfiguration(config);\n    /**\n     * @typedef {runner} runnerComponent\n     */\n\n    var runnerComponent = component({\n      /**\n       * Gets the option's value\n       * @param {String} name - the option key\n       * @returns {*}\n       */\n      getOption: function getOption(name) {\n        return this.config.options[name];\n      },\n\n      /**\n       * Gets the test runner\n       * @returns {runner}\n       */\n      getRunner: function getRunner() {\n        return runner;\n      }\n    }).setTemplate(template).on('init', function () {\n      var _this = this;\n\n      //load the defined providers for the runner, the proxy, the communicator, the plugins, etc.\n      return providerLoader(config.providers, config.loadFromBundle).then(function (results) {\n        if (results && results.plugins) {\n          plugins = results.plugins;\n        }\n\n        _this.render(container);\n\n        _this.hide();\n      }).catch(function (err) {\n        return _this.trigger('error', err);\n      });\n    }).on('render', function () {\n      var _this2 = this;\n\n      var runnerConfig = Object.assign(_.omit(this.config, ['providers']), {\n        renderTo: this.getElement()\n      });\n      runnerConfig.provider = Object.keys(this.config.providers).reduce(function (acc, providerType) {\n        if (!acc[providerType] && providerType !== 'plugins') {\n          acc[providerType] = getSelectedProvider(providerType, _this2.config);\n        }\n\n        return acc;\n      }, runnerConfig.provider || {});\n      runner = runnerFactory(runnerConfig.provider.runner, plugins, runnerConfig).on('ready', function () {\n        _.defer(function () {\n          _this2.setState('ready').trigger('ready', runner).show();\n        });\n      }).on('destroy', function () {\n        return runner = null;\n      }).spread(this, 'error').init();\n    }).on('destroy', function () {\n      var destroying = runner && runner.destroy();\n      runner = null;\n      return destroying;\n    }).after('destroy', function () {\n      this.removeAllListeners();\n    });\n    return runnerComponent.init(config);\n  }\n\n  return runnerComponentFactory;\n\n});\n\n","define('taoTests/runner/testStore',['lodash', 'core/store', 'core/logger'], function (_, store, loggerFactory) { 'use strict';\n\n    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;\n    store = store && Object.prototype.hasOwnProperty.call(store, 'default') ? store['default'] : store;\n    loggerFactory = loggerFactory && Object.prototype.hasOwnProperty.call(loggerFactory, 'default') ? loggerFactory['default'] : loggerFactory;\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2017-2019 (original work) Open Assessment Technologies SA\n     *\n     */\n    /**\n     * The test store logger\n     * @type {core/logger}\n     */\n\n    var logger = loggerFactory('taoQtiTest/runner/provider/testStore');\n    /**\n     * Database name prefix (suffixed by the test identifier)\n     * to check if we use the fragmented mode\n     * or the unified mode.\n     * @type {String[]}\n     */\n\n    var legacyPrefixes = ['actions-', 'duration-', 'test-probe', 'timer-'];\n    /**\n     * List the available modes\n     */\n\n    var modes = {\n      unified: 'unified',\n      //one db per test, new mode\n      fragmented: 'fragmented' //mutliple dbs per test, legacy mode\n\n    };\n    /**\n     * Check and select the store mode.\n     * If any of the \"legacyPrefixes\" store is found, we used the fragmented mode\n     * otherwise we'll use the unified mode.\n     * @param {String} testId\n     * @param {Object} [preselectedBackend] - the storage backend\n     * @returns {Promise<String>} resolves with the mode of the current test\n     */\n\n    var selectStoreMode = function selectStoreMode(testId, preselectedBackend) {\n      return store.getAll(function validate(storeName) {\n        return _.some(legacyPrefixes, function (prefix) {\n          return !_.isEmpty(storeName) && prefix + testId === storeName;\n        });\n      }, preselectedBackend).then(function (foundStores) {\n        if (_.isArray(foundStores) && foundStores.length > 0) {\n          return modes.fragmented;\n        }\n\n        return modes.unified;\n      });\n    };\n    /**\n     * Get the store for the given test\n     *\n     * @param {String} testId - unique test instance id\n     * @returns {testStore} a 'wrapped' store instance\n     * @param {Object} [preselectedBackend] - the storage backend (automatically selected by default)\n     * @throws {TypeError} without a testId\n     */\n\n\n    function testStoreLoader(testId, preselectedBackend) {\n      var storeNames = [];\n      var volatiles = [];\n      var changeTracking = {};\n      var testMode;\n      /**\n       * Is the test using a unified store mode ?\n       * @returns {Promise<Boolean>} true if unified\n       */\n\n      var isStoreModeUnified = function isStoreModeUnified() {\n        if (_.isUndefined(testMode)) {\n          return selectStoreMode(testId, preselectedBackend).then(function (result) {\n            if (result && typeof modes[result] !== 'undefined') {\n              testMode = result;\n            } else {\n              //use the unified mode by default\n              testMode = modes.unified;\n            }\n\n            logger.debug(\"Test store mode \".concat(result, \" for \").concat(testId));\n            return result === modes.unified;\n          });\n        }\n\n        return Promise.resolve(testMode === modes.unified);\n      };\n\n      if (_.isEmpty(testId)) {\n        throw new TypeError('The store must be identified with a unique test identifier');\n      }\n      /**\n       * Wraps a store and add the support of \"volatile\" storages\n       * @typedef {Object} testStore\n       */\n\n\n      return {\n        /**\n         * Get a wrapped store instance, that let's you use multiple stores inside one store...\n         * (or in multiple stores if the test is in legacy mode)\n         * @param {String} storeName - the name of the sub store\n         * @returns {Promise<storage>}\n         */\n        getStore: function getStore(storeName) {\n          //call when the current storge has been changed\n          //only if the store is set to track changes\n          var trackChange = function trackChange() {\n            if (_.isBoolean(changeTracking[storeName])) {\n              changeTracking[storeName] = true;\n            }\n          };\n\n          if (_.isEmpty(storeName)) {\n            throw new TypeError('A store name must be provided to get the store');\n          }\n\n          if (!_.contains(storeNames, storeName)) {\n            storeNames.push(storeName);\n          }\n\n          return isStoreModeUnified().then(function (isUnified) {\n            var loadStore;\n\n            if (isUnified) {\n              loadStore = store(testId, preselectedBackend);\n            } else {\n              loadStore = store(\"\".concat(storeName, \"-\").concat(testId), preselectedBackend);\n            }\n\n            return loadStore.then(function (loadedStore) {\n              var keyPattern = new RegExp(\"^\".concat(storeName, \"__\"));\n\n              var storeKey = function storeKey(key) {\n                return isUnified ? \"\".concat(storeName, \"__\").concat(key) : key;\n              };\n              /**\n               * The wrapped storage\n               * @type {Object}\n               */\n\n\n              return {\n                /**\n                 * Get an item with the given key\n                 * @param {String} key\n                 * @returns {Promise<*>} with the result in resolve, undefined if nothing\n                 */\n                getItem: function getItem(key) {\n                  return loadedStore.getItem(storeKey(key));\n                },\n\n                /**\n                 * Get all store items\n                 * @returns {Promise<Object>} with a collection of items\n                 */\n                getItems: function getItems() {\n                  if (isUnified) {\n                    return loadedStore.getItems().then(function (entries) {\n                      return _.transform(entries, function (acc, entry, key) {\n                        if (keyPattern.test(key)) {\n                          acc[key.replace(keyPattern, '')] = entry;\n                        }\n\n                        return acc;\n                      }, {});\n                    });\n                  } else {\n                    return loadedStore.getItems();\n                  }\n                },\n\n                /**\n                 * Set an item with the given key\n                 * @param {String} key - the item key\n                 * @param {*} value - the item value\n                 * @returns {Promise<Boolean>} with true in resolve if added/updated\n                 */\n                setItem: function setItem(key, value) {\n                  trackChange();\n                  return loadedStore.setItem(storeKey(key), value);\n                },\n\n                /**\n                 * Remove an item with the given key\n                 * @param {String} key - the item key\n                 * @returns {Promise<Boolean>} with true in resolve if removed\n                 */\n                removeItem: function removeItem(key) {\n                  trackChange();\n                  return loadedStore.removeItem(storeKey(key));\n                },\n\n                /**\n                 * Clear the current store\n                 * @returns {Promise<Boolean>} with true in resolve once cleared\n                 */\n                clear: function clear() {\n                  trackChange();\n\n                  if (isUnified) {\n                    return loadedStore.getItems().then(function (entries) {\n                      _.forEach(entries, function (entry, key) {\n                        if (keyPattern.test(key)) {\n                          loadedStore.removeItem(key);\n                        }\n                      });\n                    });\n                  } else {\n                    return loadedStore.clear();\n                  }\n                }\n              };\n            });\n          });\n        },\n\n        /**\n         * Define the given store as \"volatile\".\n         * It means the store data can be revoked\n         * if the user change browser for example\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {testStore} chains\n         */\n        setVolatile: function setVolatile(storeName) {\n          if (!_.contains(volatiles, storeName)) {\n            volatiles.push(storeName);\n          }\n\n          return this;\n        },\n\n        /**\n         * Check the given storeId. If different from the current stored identifier\n         * we initiate the invalidation of the volatile data.\n         * @param {String} storeId - the id to check\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileIfStoreChange: function clearVolatileIfStoreChange(storeId) {\n          var self = this;\n          var shouldClear = false;\n          return store.getIdentifier(preselectedBackend).then(function (savedStoreId) {\n            if (!_.isEmpty(storeId) && !_.isEmpty(savedStoreId) && savedStoreId !== storeId) {\n              logger.info(\"Storage change detected (\".concat(savedStoreId, \" != \").concat(storeId, \") => volatiles data wipe out !\"));\n              shouldClear = true;\n            }\n\n            return shouldClear;\n          }).then(function (clear) {\n            if (clear) {\n              return self.clearVolatileStores();\n            }\n\n            return false;\n          });\n        },\n\n        /**\n         * Clear the storages marked as volatile\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileStores: function clearVolatileStores() {\n          var self = this;\n          var clearing = volatiles.map(function (storeName) {\n            return self.getStore(storeName).then(function (storeInstance) {\n              return storeInstance.clear();\n            });\n          });\n          return Promise.all(clearing).then(function (results) {\n            return results && results.length === volatiles.length;\n          });\n        },\n\n        /**\n         * Observe changes on the given store\n         *\n         * @param {String} storeName - the name of the store to observe\n         * @returns {testStore} chains\n         */\n        startChangeTracking: function startChangeTracking(storeName) {\n          changeTracking[storeName] = false;\n          return this;\n        },\n\n        /**\n         * Has the store some changes\n         *\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {Boolean} true if the given store has some changes\n         */\n        hasChanges: function hasChanges(storeName) {\n          return changeTracking[storeName] === true;\n        },\n\n        /**\n         * Reset the change listening\n         *\n         * @param {String} storeName - the name of the store\n         * @returns {testStore} chains\n         */\n        resetChanges: function resetChanges(storeName) {\n          if (_.isBoolean(changeTracking[storeName])) {\n            changeTracking[storeName] = false;\n          }\n\n          return this;\n        },\n\n        /**\n         * Remove the whole store\n         * @returns {Promise<Boolean>} true if done\n         */\n        remove: function remove() {\n          var legacyStoreExp = new RegExp(\"-\".concat(testId, \"$\"));\n          return isStoreModeUnified().then(function (isUnified) {\n            if (isUnified) {\n              return store(testId, preselectedBackend).then(function (storeInstance) {\n                return storeInstance.removeStore();\n              });\n            }\n\n            return store.removeAll(function (storeName) {\n              return legacyStoreExp.test(storeName);\n            }, preselectedBackend);\n          });\n        },\n\n        /**\n         * Wraps the identifier retrieval\n         * @returns {Promise<String>} the current store id\n         */\n        getStorageIdentifier: function getStorageIdentifier() {\n          return store.getIdentifier(preselectedBackend);\n        }\n      };\n    }\n\n    return testStoreLoader;\n\n});\n\n","\ndefine(\"taoTests/loader/taoTestsRunner.bundle\", function(){});\n","define(\"taoTests/loader/taoTestsRunner.min\", [\"taoItems/loader/taoItems.min\"], function(){});\n"]}